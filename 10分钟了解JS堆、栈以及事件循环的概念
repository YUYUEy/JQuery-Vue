前言
其实一开始对栈、堆的概念特别模糊，只知道好像跟内存有关，又好像事件循环也沾一点边。面试薄荷的时候，面试官正好也问到了这个问题，当时只能大方的承认不会。
痛定思痛，回去好好的研究一番。
我们将从JS的内存机制以及事件机制和大量的🌰（例子）来了解栈、堆究竟是个什么玩意。概念比较多，不用死读，所有的🌰心里想一遍，浏览器console看一遍就
很清楚了。
let's go
JS内存机制
因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不专业的朋友在进入到
前端之后，会对内存空间的认知比较模糊。
在JS中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stack)与堆内存(heap)。
栈内存一般储存基础数据类型
 Number String Null Undefined Boolean 
 (es6新引入了一种数据类型，Symbol)
复制代码最简单的🌰
var a = 1 
复制代码我们定义一个变量a，系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。
数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。
堆内存一般储存引用数据类型
堆内存的🌰
var b = { xi : 20 }
复制代码与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许
直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。看一下下面的图，加深理解

//
var a1 = 0;   // 栈 
var a2 = 'this is string'; // 栈
var a3 = null; // 栈

var b = { m: 20 }; // 变量b存在于栈中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
复制代码因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），
然后再从堆内存中取得我们需要的数据。
/*********************************************/


对象放在heap（堆）里，常见的基础类型和函数放在stack（栈）里，函数执行的时候在栈里执行。栈里函数执行的时候可能会调一些Dom操作，
ajax操作和setTimeout定时器，这时候要等stack（栈）里面的所有程序先走**（注意：栈里的代码是先进后出）**，走完后再走WebAPIs，WebAPIs执行
后的结果放在callback queue（回调的队列里，注意：队列里的代码先放进去的先执行），也就是当栈里面的程序走完之后，再从任务队列中读取事件，
将队列中的事件放到执行栈中依次执行，这个过程是循环不断的。

1.所有同步任务都在主线程上执行，形成一个执行栈
2.主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。
3.一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行
4.主线程从任务队列中读取事件，这个过程是循环不断的

概念又臭又长，没关系，我们先粗略的扫一眼，接着往下看。
举一个🌰说明栈的执行方式
var a = "aa";
function one(){
    let a = 1;
    two();
    function two(){
        let b = 2;
        three();
        function three(){
            console.log(b)
        }
    }
}
console.log(a);
one();
复制代码
demo的结果是
aa
2

/*******************************/
总结回顾


栈：

存储基础数据类型
按值访问
存储的值大小固定
由系统自动分配内存空间
空间小，运行效率高
先进后出，后进先出
栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。
微任务和宏任务



堆:

存储引用数据类型
按引用访问
存储的值大小不定，可动态调整
主要用来存放对象
空间大，但是运行效率相对较低
无序存储，可根据引用直接获取

//
作者：薄荷前端
链接：https://juejin.im/post/5b1deac06fb9a01e643e2a95
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
